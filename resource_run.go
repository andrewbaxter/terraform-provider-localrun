package main

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	resourceschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

type RunResourceModel struct {
	Command     []string          `tfsdk:"command"`
	Environment map[string]string `tfsdk:"environment"`
	WorkingDir  string            `tfsdk:"working_dir"`
	Output      string            `tfsdk:"output"`
	OutputHash  string            `tfsdk:"output_hash"`
	AutoUpdate  int64             `tfsdk:"_auto_update"`
}

type RunResource struct {
}

// Metadata implements resource.Resource
func (RunResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_run"
}

// Schema implements resource.Resource
func (RunResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = resourceschema.Schema{
		Description: "Run a command",
		Attributes: map[string]resourceschema.Attribute{
			"command": resourceschema.ListAttribute{
				Description: "Command to run; first element is executable, remaining elements are arguments",
				ElementType: types.StringType,
				Required:    true,
			},
			"environment": resourceschema.MapAttribute{
				Description: "Environment variables; inherits terraform's environment",
				ElementType: types.StringType,
				Optional:    true,
			},
			"working_dir": resourceschema.StringAttribute{
				Description: "Working directory in which to run command",
				Optional:    true,
			},
			"output": resourceschema.StringAttribute{
				Description: "The path to a file generated by the command; the hash of this is placed in `output_hash` after execution",
				Optional:    true,
			},
			"output_hash": resourceschema.StringAttribute{
				Description: "The hash of the output file, updated after execution",
				Computed:    true,
			},
			"_auto_update": resourceschema.Int64Attribute{
				Description: "Internal, don't use",
				Optional:    true,
			},
		},
	}
}

func (RunResource) run(state *RunResourceModel, diagnostics *diag.Diagnostics) {
	cmd := exec.Command(state.Command[0], state.Command[1:]...)
	env := map[string]string{}
	for _, e := range os.Environ() {
		parts := strings.SplitN(e, "=", 2)
		env[parts[0]] = parts[1]
	}
	for k, v := range state.Environment {
		env[k] = v
	}
	env1 := []string{}
	for k, v := range env {
		env1 = append(env1, fmt.Sprintf("%s=%s", k, v))
	}
	cmd.Env = env1
	cmd.Dir = state.WorkingDir
	out, err := cmd.CombinedOutput()
	if err != nil {
		diagnostics.AddError("Run failed", string(out))
		return
	}

	if state.Output != "" {
		digest := sha256.New()
		f, err := os.Open(state.Output)
		if err != nil {
			diagnostics.AddError("Failed to open output file", err.Error())
		}
		defer func() {
			err := f.Close()
			if err != nil {
				diagnostics.AddWarning("Failed to close output file", err.Error())
			}
		}()
		_, err = io.Copy(digest, f)
		if err != nil {
			diagnostics.AddError("Failed to hash output file", err.Error())
		}
		state.OutputHash = hex.EncodeToString(digest.Sum([]byte{}))
	}
}

// Create implements resource.Resource
func (r RunResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state RunResourceModel
	diags := req.Plan.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	r.run(&state, &resp.Diagnostics)

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// Delete implements resource.Resource
func (RunResource) Delete(context.Context, resource.DeleteRequest, *resource.DeleteResponse) {
	// nop
}

// Update implements resource.Resource
func (r RunResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var state RunResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	r.run(&state, &resp.Diagnostics)

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// Read implements resource.Resource
func (RunResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state RunResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	state.AutoUpdate = state.AutoUpdate + 1

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}
