package main

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	resourceschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

type RunResourceModel struct {
	Command      []types.String                `tfsdk:"command"`
	Environment  map[types.String]types.String `tfsdk:"environment"`
	WorkingDir   types.String                  `tfsdk:"working_dir"`
	Outputs      []types.String                `tfsdk:"outputs"`
	OutputHashes types.List                    `tfsdk:"output_hashes"`
}

type RunResource struct {
}

// Metadata implements resource.Resource
func (RunResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_run"
}

// Schema implements resource.Resource
func (RunResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = resourceschema.Schema{
		Description: "Run a command",
		Attributes: map[string]resourceschema.Attribute{
			"command": resourceschema.ListAttribute{
				Description: "Command to run; first element is executable, remaining elements are arguments",
				ElementType: types.StringType,
				Required:    true,
			},
			"environment": resourceschema.MapAttribute{
				Description: "Environment variables; inherits terraform's environment",
				ElementType: types.StringType,
				Optional:    true,
			},
			"working_dir": resourceschema.StringAttribute{
				Description: "Working directory in which to run command; defaults to current directory",
				Optional:    true,
			},
			"outputs": resourceschema.ListAttribute{
				Description: "Paths to files generated by the command, relative to working directory; the hashes of these are placed in `output_hashes` after execution",
				Optional:    true,
				ElementType: types.StringType,
			},
			"output_hashes": resourceschema.ListAttribute{
				Description: "The hashes of the output files, updated after execution",
				Computed:    true,
				ElementType: types.StringType,
			},
		},
	}
}
func (r RunResource) run(state *RunResourceModel, diagnostics *diag.Diagnostics) {
	cmd0 := []string{}
	for _, c := range state.Command {
		cmd0 = append(cmd0, c.ValueString())
	}
	cmd := exec.Command(cmd0[0], cmd0[1:]...)
	env := map[string]string{}
	for _, e := range os.Environ() {
		parts := strings.SplitN(e, "=", 2)
		env[parts[0]] = parts[1]
	}
	for k, v := range state.Environment {
		env[k.ValueString()] = v.ValueString()
	}
	env1 := []string{}
	for k, v := range env {
		env1 = append(env1, fmt.Sprintf("%s=%s", k, v))
	}
	cmd.Env = env1
	cmd.Dir = state.WorkingDir.ValueString()
	out, err := cmd.CombinedOutput()
	if err != nil {
		diagnostics.AddError("Run failed", string(out))
		return
	}
}

func (r RunResource) updateHashes(state *RunResourceModel, diagnostics *diag.Diagnostics) {
	out := []attr.Value{}
	for _, o := range state.Outputs {
		p, err := filepath.Abs(filepath.Join(state.WorkingDir.ValueString(), o.ValueString()))
		if err != nil {
			panic(err)
		}
		digest := sha256.New()
		f, err := os.Open(p)
		if err != nil {
			diagnostics.AddError("Failed to open output file "+p, err.Error())
			goto Err
		}
		defer func() {
			err := f.Close()
			if err != nil {
				diagnostics.AddWarning("Failed to close output file "+p, err.Error())
			}
		}()
		_, err = io.Copy(digest, f)
		if err != nil {
			diagnostics.AddError("Failed to hash output file "+p, err.Error())
			goto Err
		}
		out = append(out, types.StringValue(hex.EncodeToString(digest.Sum([]byte{}))))
		continue
	Err:
		out = append(out, types.StringValue("error"))
	}
	var diags diag.Diagnostics
	state.OutputHashes, diags = types.ListValue(types.StringType, out)
	diagnostics.Append(diags...)
	if diagnostics.HasError() {
		return
	}
}

// Create implements resource.Resource
func (r RunResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state RunResourceModel
	diags := req.Plan.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	r.run(&state, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	r.updateHashes(&state, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// Delete implements resource.Resource
func (RunResource) Delete(context.Context, resource.DeleteRequest, *resource.DeleteResponse) {
	// nop
}

// Update implements resource.Resource
func (r RunResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var state RunResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	r.updateHashes(&state, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// Read implements resource.Resource
func (r RunResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state RunResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	r.run(&state, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}
